import datetime
import numpy as np
import pandas as pd
import Queue

from abc import ABCMeta, abstractmethod
from contextlib import contextmanager
import sys, os
from statsmodels.tsa.arima_model import ARIMA


from Event import SignalEvent





class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars 
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")

class ARIMAGARCHStrategy(Strategy):
    
    def __init__(self,bars,events):
        """
        Initialise the ARIMA/GARCH Strategy
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()
    
    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are 
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object. 
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=200)
                if bars is not None and bars != [] and len(bars) > 199:
                    
                        hist_data = pd.DataFrame(bars).as_matrix()[:,3].tolist()
                        pred = self.generate_prediction(hist_data)
                        if self.bought[s] == False:
                            if pred == 1:
                                # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                                signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                                self.events.put(signal)
                                self.bought[s] = True
                         #   if pred == -1:
                          ##      # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                                signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT')
                            #    self.events.put(signal)
                             #   self.bought[s] = True
                        else:
                            if pred == -1:
                                signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT')
                                self.events.put(signal)
                                self.bought[s] = False
                        

    def generate_prediction(self,hist_data):
        y=pd.Series(np.diff(np.log(np.array(hist_data)))).tolist()
        #print y
        AIC=1e5
        order=[0.0,0.0,0.0]
        for i in range(1,2):
            for j in range(1,2):
                for d in range(0,1):
                    #print i,d,j
                    try:
                        with suppress_stdout():
                            model2=ARIMA(y,order=(i,d,j))
                            model2_fit=model2.fit(disp=0)
                            caic=model2_fit.aic
                            if caic < AIC:
                                AIC=caic
                                order=[i,d,j]
                    except (ValueError,np.linalg.linalg.LinAlgError, ValueError) as e:
                        pass
         
        model=ARIMA(y,order=(order[0],order[1],order[2]))
        model_fit=model2.fit(disp=0)
        res=model2_fit.resid
        pred=model_fit.predict(start=-1, end=-1, dynamic=False) 
        print pred
        return np.sign(pred)
        
@contextmanager
def suppress_stdout():
    with open(os.devnull, "w") as devnull:
        old_stdout = sys.stdout
        sys.stdout = devnull
        try:  
            yield
        finally:
            sys.stdout = old_stdout





class NaiveMomentumStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the 
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, events,debug=0):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Once buy & hold signal is given, these are set to True
        self.bought, self.short = self._calculate_initial_bought()
        self.debug = debug

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        short = {}
        for s in self.symbol_list:
            bought[s] = False
            short[s] = False
        return bought, short

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are 
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object. 
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=200)
                if bars is not None and bars != [] and len(bars) > 10:
                    hist_data = pd.DataFrame(bars).as_matrix()[:,3].tolist()
                    pred = self.generate_prediction(hist_data,30,1e-4)
                    if self.debug == 1:
                            print 'Predicting p=', pred
                    if pred == -1:
                        if self.short[s] == False:
                            signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT')
                            self.events.put(signal)
                            self.short[s] = True
                        if self.bought[s] == True:
                            signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT')
                            self.events.put(signal)
                            self.bought[s] = False
                    if pred == 1:
                        if self.short[s] == True:
                            signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT')
                            self.events.put(signal)
                            self.short[s] = False
                        if self.bought[s] == False:
                            signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                            self.events.put(signal)
                            self.bought[s] = True
                            
                            
                    #if self.bought[s] == False:
                     #   signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT')
                      #  self.events.put(signal)
                       # self.bought[s] = True
                        #if self.debug == 1:
                         #   print 'Going short!'

                    #if pred == 1:
                        #if self.bought == True:
                         #   signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT')
                          #  self.events.put(signal)
                           # self.bought[s] = False
                        
                            
                  #  if pred == 1:
                   #     if self.bought == False:
                    #        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                     #       self.events.put(signal)
                      #      self.bought[s] = True
                       # elif self.short == True:
                        #    signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT')
                         #   self.events.put(signal)
                          #  self.short[s] = False
               #     elif pred == -1:
                #        if self.bought == True:
                 #           signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT')
                  #          self.events.put(signal)
                   #         self.bought[s] = False
                    #    elif self.short == False:
                     #       signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT')
                       #     self.events.put(signal)
                      #      self.short[s] = True
                        
                            
                            
                    """
                    if self.bought[s] == False:
                        if pred == 1:
                            # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                            signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                            self.events.put(signal)
                            self.bought[s] = True
                        #if pred == -1:
                         #       # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                          #      signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT')
                           #     self.events.put(signal)
                            #    self.bought[s] = True
                    else:
                        if pred == -1:
                            signal = SignalEvent(bars[0][0], bars[0][1], 'EXIT')
                            self.events.put(signal)
                            self.bought[s] = False
                    """
        
    def generate_prediction(self,hist_data,N,k):
        N_mean = np.mean(hist_data[-N:])
        if hist_data[-1] > (1+k) * N_mean:
            pred = -1
        elif hist_data[-1] < (1-k) * N_mean:
            pred = 1
        else: 
            pred = 0
        return pred
                    
        



